(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{518:function(n,t,a){"use strict";a.r(t);var s=a(30),e=Object(s.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h3",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[n._v("#")]),n._v(" 概述")]),n._v(" "),a("p",[n._v("Go语言的并发模型是CSP，提倡通过通信共享内存而不是通过共享内存而实现通信。\n如果说goroutine是Go程序并发对执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。\nGo语言中的通道channel是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出的原则，保证收发数据的顺序，每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。")]),n._v(" "),a("p",[n._v("channel是一种类型，一种引用类型，通道类型的空值是nil。声明通道类型的格式如下：")]),n._v(" "),a("div",{staticClass:"language-go line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("var")]),n._v(" ch1 "),a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("chan")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[n._v("int")]),n._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("var")]),n._v(" ch2 "),a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("chan")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[n._v("bool")]),n._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("var")]),n._v(" ch3 "),a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("chan")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[n._v("int")]),n._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[n._v("//声明一个传递int切片的通道")]),n._v("\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br")])]),a("h5",{attrs:{id:"channel操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#channel操作"}},[n._v("#")]),n._v(" channel操作")]),n._v(" "),a("p",[n._v("通道有发送（send）、接收（receive）和关闭（close）三种操作。\n发送和接收都使用<-符号")]),n._v(" "),a("p",[n._v("关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。")]),n._v(" "),a("p",[n._v("关闭后的通道有以下特点：")]),n._v(" "),a("ul",[a("li",[n._v("对一个关闭的通道再发送值就会导致panic")]),n._v(" "),a("li",[n._v("对一个关闭的通道进行接收会一直获取值直到通道为空")]),n._v(" "),a("li",[n._v("对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值")]),n._v(" "),a("li",[n._v("关闭一个已经关闭的通道会导致panic")])]),n._v(" "),a("p",[n._v("无缓冲通道上的发送操作会阻塞，直到另一个goroutine再该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine再该通道上发送一个值。\n使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也称为同步通道。")]),n._v(" "),a("h5",{attrs:{id:"单向通道"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单向通道"}},[n._v("#")]),n._v(" 单向通道")]),n._v(" "),a("p",[n._v("chan<- 是一个只能发送的通道，可以发送，但是不可以接收\n<-chan 是一个只能接收的通道，可以接收，但是不可以发送")]),n._v(" "),a("p",[n._v("在函数传参及任何赋值操作中将双向通道转换为单向通道是可以的，但是反过来是不可以的。")])])}),[],!1,null,null,null);t.default=e.exports}}]);